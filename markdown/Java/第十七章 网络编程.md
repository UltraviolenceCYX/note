# 类加载机制与反射

## 类的加载

​	当程序用到某个类，还没有被加载到内存时，会通过加载，连接，初始化这三个步骤。

* 类加载：将类的class文件读入内存中，并建立一个java.lang.Class对象，使用任何类系统都会建立一个这个对象 
* 类的连接：（1）验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调 一致。 （2）准备：类准备阶段则负责为类的类变量分配内存，并设置默认初始值。 （3）解析：将类的二进制数据中的符号引用替换成直接引用。
* 类的初始化：① 假如这个类还没有被加载和连接，则程序先加载并连接该类。 ② 假如该类的直接父类还没有被初始化，则先初始化其直接父类。 ③ 假如类中有初始化语句，则系统依次执行这些初始化语句。所以object类总是最先被初始化。

## 类初始化的时机

➢ 创建类的实例。为某个类创建实例的方式包括：使用new操作符来创建实例，通过 反射来创建实例，通过反序列化的方式来创建实例。 

➢ 调用某个类的类方法（静态方法）。

 ➢ 访问某个类或接口的类变量，或为该类变量赋值。 

➢ 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。例如代码： Class.forName（"Person"），如果系统还未初始化Person类，则这行代码将会导致 该Person类被初始化，并返回Person类对应的java.lang.Class对象。关于Class的 forName方法请参考18.3节。

 ➢ 初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被初始化。

 ➢ 直接使用java.exe命令来运行某个主类。当运行某个主类时，程序会先初始化该主 类。

> 对于一个final修饰的变量，如果可以被确定下来而不需要计算，相当于是常量，引用它不会引起类的初始化

## 类加载器

​	在 Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其 全限定类名和其类加载器作为唯一标识。例如，如果在pg的包中有一个名为Person的类， 被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为 （Person、pg、kl）。这意味着两个类加载器加载的同名类：（Person、pg、kl）和 （Person、pg、kl2）是不同的，它们所加载的类也是完全不同、互不兼容的。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构。

➢ Bootstrap ClassLoader：根类加载器。 

➢ Extension ClassLoader：扩展类加载器。

 ➢ System ClassLoader：系统类加载器。

---

## 反射

​	Java程序中的许多对象在运行时都会出现两种类型：编译时类型和运行时类型，例如 代码：Person p=new Student();，这行代码将会生成一个p变量，该变量的编译时类型为 Person，运行时类型为Student；除此之外，还有更极端的情形，程序在运行时接收到外部 传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象运行时类型的方法。

### 获得class对象

​	前面已经介绍过了，每个类被加载之后，系统就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。

➢ 使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数， 该字符串参数的值是某个类的全限定类名（必须添加完整包名）。

 ➢ 调用某个类的class属性来获取该类对应的Class对象。例如，Person.class将会返回 Person类对应的Class对象。

 ➢ 调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法，所以所 有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。

### 从class中获取信息

​	可以通过class对象获取构造器，方法，成员变量，注解

### 通过反射生成并操作对象

* 创建对象：通过反射来生成对象需要先使用Class对象获取指定的Constructor对象，再调用 Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以 选择使用指定的构造器来创建实例。

* 调用方法：当获得某个类对应的Class对象后，就可以通过该Class对象的getMethods()方法或者 getMethod()方法来获取全部方法或指定方法——这两个方法的返回值是Method数组，或者Method对象。 每个Method对象对应一个方法，获得Method对象后，程序就可通过该Method来调用 它对应的方法。在Method里包含一个invoke()方法，该方法的签名如下。 

  ➢ Object invoke(Object obj, Object...args)：该方法中的obj是执行该方法的主调，后面 的args是执行该方法时传入该方法的实参。

## 通过反射生成JDK动态代理

​	在Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过 使用这个类和接口可以生成JDK动态代理类或动态代理对象。

## 反射和泛型

​	从JDK 5以后，Java的Class类增加了泛型功能，从而允许使用泛型来限制Class类，例 如，String.class的类型实际上是Class。如果Class对应的类暂时未知，则使用 Class。通过在反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。
